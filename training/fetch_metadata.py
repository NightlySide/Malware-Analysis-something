import subprocess
import requests
from dataclasses import dataclass, field
import sqlite3
import sys
import json
import os
import tqdm
from joblib import Parallel, delayed
from contextlib import closing
import argparse
from time import sleep

# config
TO_IGNORE = [".gitkeep"]
INCLUDE_TYPES = ["PE32", "ELF"]


@dataclass
class Metadata:
    sha256: str = ""
    file_name: str = ""
    file_size: int = 0
    file_type_mime: str = ""
    file_type: str = ""
    signature: str = ""
    ssdeep: str = ""
    tags: list = field(default_factory=list)

    @staticmethod
    def from_malware_bazaar(data: dict) -> "Metadata":
        return Metadata(
            sha256=data["sha256_hash"],
            file_name=data["file_name"],
            file_size=data["file_size"],
            file_type_mime=data["file_type_mime"],
            file_type=data["file_type"],
            signature=data["signature"],
            ssdeep=data["ssdeep"],
            tags=data["tags"],
        )


def get_file_from_magic(path: str) -> str:
    # use the file command on linux to get info on the file
    out = subprocess.check_output(f"file {path}", shell=True)
    return out.decode().strip()


def get_metadata_for_hash(hash: str, try_again: bool = True) -> Metadata | None:
    # setup the request for info
    URL = "https://mb-api.abuse.ch/api/v1/"
    data = {"query": "get_info", "hash": hash}

    # make the request
    try:
        res = requests.post(URL, data=data, timeout=60, allow_redirects=True)
        res_json = res.json()

        # check that the data has been found in the depot
        if res_json["query_status"] == "hash_not_found":
            print(f"[-] Hash not found: {hash}")
            return None

        data = res_json["data"][0]
    except Exception as e:
        print(f"ERROR: {e}")
        print(f"with content: {res.content}")

        sleep(2.0)
        if try_again:
            return get_metadata_for_hash(hash, try_again=False)
        else:
            return None

    # parse the data
    meta = Metadata.from_malware_bazaar(data)

    return meta


def create_table_in_db(path: str):
    print("[^] Creating malware table in the db")
    with closing(sqlite3.connect(path, timeout=60)) as conn:
        cursor = conn.cursor()
        cursor.execute(
            """CREATE TABLE IF NOT EXISTS `malwares` (
            `sha256` TEXT(64) NOT NULL,
            `file_name` TEXT(256) NOT NULL,
            `file_size` INT(20) NOT NULL,
            `file_type_mime` TEXT(30) NOT NULL,
            `file_type` TEXT(20) NOT NULL,
            `signature` TEXT(40) NOT NULL,
            `ssdeep` TEXT(148) NOT NULL,
            `tags` TEXT(200) NOT NULL,
            PRIMARY KEY (`sha256`)
        );"""
        )
        conn.commit()


def get_hashes_in_db(path: str) -> list[str]:
    print("[^] Getting the list of hashes in the db")
    with closing(sqlite3.connect(path, timeout=60)) as conn:
        cursor = conn.cursor()
        res = cursor.execute("SELECT sha256 FROM malwares;")
        hashes = [row[0] for row in res.fetchall()]
    print(f"[+] Found {len(hashes)} hashes in the db")
    return hashes


def add_meta_to_db(path: str, meta: Metadata):
    with closing(sqlite3.connect(path, timeout=60)) as conn:
        cursor = conn.cursor()

        file_name = meta.file_name.replace("'", "")
        query = f"""INSERT INTO malwares VALUES ('{meta.sha256}', '{file_name}', {meta.file_size}, '{meta.file_type_mime}', '{meta.file_type}', '{meta.signature}', '{meta.ssdeep}', '{json.dumps(meta.tags)}');"""

        try:
            cursor.execute(query)
        except Exception as e:
            print(f"SQL ERROR: {query}")
            raise e
        conn.commit()


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--input",
        help="Input folder where the samples are",
        default="./samples",
        nargs="?",
    )
    parser.add_argument(
        "-o",
        "--output",
        help="The output sqlite DB where the metadata will be stored",
        default="malwares.sqlite",
        nargs="?",
    )
    return parser.parse_args()


def main():
    # parse args
    args = parse_args()

    # init db with migration
    print("[^] Init db")
    create_table_in_db(args.output)

    # get the list of already analysed hashes
    hashes = get_hashes_in_db(args.output)

    def process_file(file: str):
        # check if the file needs to be ignored
        if file in TO_IGNORE:
            # print(f"{file} is in ignore list")
            return None

        # check if the hash is in the list
        hash = file.split(".")[0]
        if hash in hashes:
            # print(f"{hash} is already in the db")
            return None

        # check if the file is of the right type
        f_type = get_file_from_magic(os.path.join(args.input, file))
        for it in INCLUDE_TYPES:
            if it in f_type:
                break
        else:
            # not a type we know
            # print(f"{file} is not a type wanted")
            return None

        return file

    # get the list of samples to analyse
    print("[^] Listing files that needs to be analysed")
    to_analyse = Parallel(n_jobs=os.cpu_count())(
        delayed(process_file)(file)
        for file in tqdm.tqdm(
            os.listdir(args.input),
            desc="Sample analysis",
        )
    )
    to_analyse = [file for file in to_analyse if file is not None]
    print(f"[+] {len(to_analyse)} files need to be analysed")

    def process_meta(path: str, file_name: str):
        # fetch the meta for each file
        hash = file_name.split(".")[0]
        meta = get_metadata_for_hash(hash)

        # add meta only if meta was found
        if meta is not None:
            add_meta_to_db(args.output, meta)

    Parallel(n_jobs=os.cpu_count() * 4)(
        delayed(process_meta)(args.output, file)
        for file in tqdm.tqdm(
            to_analyse,
            desc="Sample analysis",
        )
    )

    return 0


if __name__ == "__main__":
    sys.exit(main())
